# 알고리즘 스택

## 기본4. 스택1 (Stack)

* 스택의 push 알고리즘

```python
def push(item):
    s.append(item)
```

* 스택의 pop 알고리즘

```python
def pop():
    if len(s) == 0:
        # underflow
        return
    else:
        return s.pop(-1)
```

len안써도 되지만 명시적으로 적어두는게 좋다.

pop하기 전에 비어있는지 확인하고; pop

* 재귀호출

자기 자신을 호출하여 순환 수행되는 것

함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성

* Memoization 방법

```python
def fibo1(n):
    global memo
    if n >= 2 and len(memo) <= n:
        memo.append(fibo1(n-1) + fibo1(n-2))
    return memo[n]

memo = [0, 1]
```



## 기본5. 스택2 (Stack)

* 중위 표기법 -> 후위 표기법 -> 계산

  ​					stack1      		 stack2

두 개의 스택이 필요

### 계산기

* step1. 중위 표기법에서 후위 표기법으로의 변환 알고리즘(스택 이용)2

1. 피연산자 - 출력

2. 연산자 - stack

3. 스택 top에 저장되어 있는 연산자보다 우선순위가 높으면 스택에 push, 그렇지 않으면 스택 top의 연산자의 우선순위가 토근의 우선순위보다 작을 때까지 스택에서 pop 한 후 토큰의 연산자를 push한다. 만약 top에 연산자가 없으면 그냥 push
4. 토큰이 ")"이면 스택 top에 "("가 올 때까지 스택에 pop 연산을 수행하고 pop한 연산자를 출력. "("을 만나면pop만 하고 출력하지 않는다.

( 스택 밖의 왼쪽 괄호는 우선 순위가 가장 높으며, 스택 안의 왼쪽 괄호는 우선순위가 가장 낮다)

(왼쪽 괄호 "("를 만나면 무조건 push하라)

5. 중위 표기식에 더 읽을 것이 없다면 중지
6. 스택에 남아 있는 연산자를 모두 pop하여 출력

정리) 

자기가 우선 순위가 더 높으면, push

자기가 우선 순위가 더 낮으면, 자기 자신보다 우선 순위가 작은 놈 나올 때까지, pop

)을 만나면, (가 나올 때까지, pop

* step2. 후위 표기법의 수식을 스택을 이용하여 계산

1. 피연산자를 만나면 스택에 push
2. 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고, 연산결과를 다시 스택에 push
3. 수식이 끝나면, 마지막으로 스택을 pop하여 출력

---

### 백트래킹

* 백트래킹 = 완전검색 + 가지치기

* 최적화 문제, 결정 문제를 해결할 수 있다.

---

###  + 재귀식(점화식) 구하는 법 (경우의 수를 확인하자)

#### (종이접기)

f(1) = 1

f(2) = 3

f(3) = 5

....

를 생각해본다. 그 후,

f(n) = ?

f(n-1) = ?

f(n-2) = ?

를 생각해보고 표현식을 세우자.

f(n) = f(n-1) + 2* f(n-2)

직접 값을 넣어 맞는 지 확인.

f(2) = f(1) + 2*f(1) //

즉 f(0)는 1의 값을 가진다. 아무것도 안하는 것도 한 가지의 방법이다.

---

구현하면 된다.

```python
def f(n):
	if n <= 1:
        return 1
    else:
        return f(n-1) + 2*(n-2)
```

DP로 구해본다면

```python
m = [1, 1]
for i in range(2, 31):
    m.append()
```

